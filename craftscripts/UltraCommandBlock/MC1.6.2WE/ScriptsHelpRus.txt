UltraCommandBlock

Глобальный скрипт для работы с командными блоками. Как дополнительный бонус включает удобное стакование.
ВАЖНО: Он работает ТОЛЬКО с выделениями типа cuboid! С остальными не работает (кроме одной команды, указано будет в её описании).
ОЧЕНЬ ВАЖНО: изменения текста внутри командных блоков не отменяются командой //undo! Это особенность WE, я её исправить не могу, поэтому думайте перед каким-либо глобальным действием, чтобы не сделать ошибки!
Команды в скрипте:
//cs UltraCommandBlock /fill <text> [space_str] - заполнить все командные блоки в выделении текстом <text>. Важно: если в вашем тексте есть пробелы, то их НЕОБХОДИМО заменит на какую либо строку/символ (по вашему желанию, БЕЗ пробелов) и указать его как space_str.
Примеры:
//cs UltraCommandBlock /fill Hello
//cs UltraCommandBlock /fill /tp___@a[x=1,y=2,z=3,r=4]___5___6___7 ___
//cs UltraCommandBlock /fill /tpTHISISSPACE@a[x=1,y=2,z=3,r=4]THISISSPACE5THISISSPACE6THISISSPACE7 THISISSPACE

//cs UltraCommandBlock /replace <text1> <text2> [space_str] - заменить <text1> на <text2> во всех командных блоках в выделении. Важно: если в вашем тексте есть пробелы, то их НЕОБХОДИМО заменит на какую либо строку/символ (по вашему желанию, БЕЗ пробелов) и указать его как space_str.
Примеры:
//cs UltraCommandBlock /replace Hello Hi
//cs UltraCommandBlock /fill Hello Go$home! $
//cs UltraCommandBlock /fill Hello,_SPACE_friends! Go_SPACE_home! _SPACE_

//cs UltraCommandBlock /clear - очищает все командные блоки в выделении.
Примеров использования даже писать не буду, ибо он только один :)

//cs UltraCommandBlock /version - узнать версию скрипта.
//cs UltraCommandBlock /author - прочитать об авторе скрипта.
//cs UltraCommandBlock /testerror - проверить наличие ошибок в командных блоках внутри выделения. Указывает саму ошибку и координаты командного блока с ошибкой. Так же предупреждает о пустых командных блоках.

Следующие команды и составляют главный функционал этого скрипта.
//cs UltraCommandBlock /stack - стакование выделения.
Подробная справка: //cs UltraCommandBlock /stack /?
//cs UltraCommandBlock /stack <number_of_stack> <mask> [flag]
number_of_stack - сколько раз произвести стакование.
mask - маска стакования. Нужна для заполнения командных блоков при стаковании. Если мы не хотим трогать командные блоки, или же их в выделении нет - пишем /no.
Формат маски стакования: NAME_PARAM_1=VALUE_PARAM_1!STEP_PARAM_1;NAME_PARAM_2=VALUE_PARAM_2!STEP_PARAM_2;...
Пример маски стакования: SuperX=1!2;SuperXX=34!45;SuperXXX=56!89;Yahoo=45!23;
Теперь разберёмся, зачем нужна маска стакования и как она используется. Внутри командных блоков мы можем использовать переменные.
Пример командного блока с переменными: /tp @a $SuperX$ $SuperXX$ $SuperXXX$
Как видим, переменная может иметь любое имя, но чтобы показать, что это переменная, мы заключаем её в знаки $. Т.е. выглядит это так: $NAME$
Причём скрипту не интересно, что именно там написано. Может быть любой текст, не обязательно команды. Например (текст в командном блоке): Ya lublu gulyat $NNN$ raz
А маска нам указывает следующее: начальное значение переменной и её шаг при стаке.
Начальное значение - сама переменная в исходном выделении. Каждый этап стакования к этой переменной прибавляется указанное второе значение. То есть маска x=1!1; положит переменную x в исходном выделении 1, в первом этапе стака 2, во втором этапе стака 3 и так далее. Может быть сколько угодно переменных. Так же, разумеется, если переменная в маске не указана - она скопируется в исходном формате. Т.е. можно делать сначала стак в одну сторону, меняя только одну переменную, потом стак вверх, к примеру, меняя вторую переменную и так далее. Подробнее это можно увидеть в видео.
Пример:
//cs UltraCommandBlock /stack 58 SuperX=1!2;SuperXX=34!45;SuperXXX=56!89;Yahoo=45!23;
Но при таком стаковании в исходном выделении переменные не изменяются. Чтобы они изменялись - надо поставить флаг /a. Чтобы не изменялись - флаг /f. Это очень важно. Если поменять в исходном выделении переменные - вы их туда уже вернуть не сможете автоматически, только руками, так как //undo не отменяет изменения внутри командных блоков.
Примеры:
//cs UltraCommandBlock /stack 58 x=1!1; /a
//cs UltraCommandBlock /stack 58 x=1!1; /f
//cs UltraCommandBlock /stack 58 /no /a
//cs UltraCommandBlock /stack 58 /no /f
Если маска /no, то этот флаг не имеет смысла (/f или /a).
Так же после этого можно ставить флаг направления (если не ставить - туда, куда смотрим).
/n - север
/w - запад
/e - восток
и так далее, по первой букве направления.
Пример: //cs UltraCommandBlock /stack 58 /no /f /u - стакуем вверх, маски нет.
Пример: //cs UltraCommandBlock /stack 58 x=1!4; /f /d - стакуем вниз, x от 1 с шагом 4, в исходном выделении ничего не меняется.
Но возникает вопрос - а зачем нам стак этот БЕЗ маски, если есть обычный стак WE?
Дело в том, что есть ещё два параметра.
Первый после направления - вектор сдвига при стаке. Каждый стак будет происходить сдвиг стакованного элемента по этому вектору. По умолчанию вектор сдвига 0,0,0.
Пример использования: //cs UltraCommandBlock /stack 58 x=1!4; /f /d 0,-1,0 - стакуем вниз, x от 1 с шагом 4, в исходном выделении ничего не меняется, при стаке каждый шаг идёт сдвиг на один блок вниз, т.е. между "большими" блоками, которые стакуются, будет расстояние в один блок. Подробнее показано в видео.
И второй параметр - блоки для стакования.
Есть две возможно - указать, какие блоки стаковать или же указать, какие блоки не стаковать.
+:id1,id2,... - стаковать ТОЛЬКО блоки с id1, id2, ...
-:id1,id2,... - стаковать ВСЕ блоки кроме тех, у которых id1, id2, ...
Поддерживается указание второго параметра id, т.е. 35:3 - шерсть определённого цвета.
Так же если мы хотим, к примеру, охватить сразу ВСЮ шерсть, пишем 35:-1, т.е. второй -1 означает, что мы берём все возможные модификации блока.
Если вы работаете с воздухом, настоятельно рекомендуется писать 0:-1 из-за ошибок генерации карты minecraft, я видел блоки воздуха с различными вторыми параметрами.
Примеры:
//cs UltraCommandBlock /stack 58 x=1!4; /a /s 0,-1,0 +:35:-1 - стакуем 58 раз на юг, маска введена, в исходном выделении переменные тоже меняются на их значения, вектор сдвига каждый раз вниз на один блок, стакуем ТОЛЬКО шерсть (ВСЮ).
//cs UltraCommandBlock /stack 58 x=1!4; /a /s 0,-1,0 +:35 - стакуем 58 раз на юг, маска введена, в исходном выделении переменные тоже меняются на их значения, вектор сдвига каждый раз вниз на один блок, стакуем ТОЛЬКО БЕЛУЮ шерсть (НЕ ВСЮ).
//cs UltraCommandBlock /stack 58 x=1!4; /a /s 0,-1,0 +:35,12 - стакуем 58 раз на юг, маска введена, в исходном выделении переменные тоже меняются на их значения, вектор сдвига каждый раз вниз на один блок, стакуем ТОЛЬКО БЕЛУЮ шерсть (НЕ ВСЮ) и песок.
//cs UltraCommandBlock /stack 58 x=1!4; /a /s 0,-1,0 -:35,12 - стакуем 58 раз на юг, маска введена, в исходном выделении переменные тоже меняются на их значения, вектор сдвига каждый раз вниз на один блок, стакуем всё, кроме БЕЛОЙ шерсти (а другие цвета стакуем!) и песка.
//cs UltraCommandBlock /stack 58 x=1!4; /a /s 0,-1,0 -:35,12 - стакуем 58 раз на юг, маска введена, в исходном выделении переменные тоже меняются на их значения, вектор сдвига каждый раз вниз на один блок, стакуем всё, кроме ЛЮБОЙ шерсти и песка.
---
//cs UltraCommandBlock /fix и //cs UltraCommandBlock /unfix
Две команды для работы с абсолютными и относительными координатами.
/fix - выполняет "фиксацию" выделения в мире, т.е. все координаты (КРОМЕ тех, которые находятся внутри квадратных скобок!) преобразовывает в абсолютные.
/unfix - выполняет "разфиксацию" выделения в мире, т.е. все координаты (КРОМЕ тех, которые находятся внутри квадратных скобок!) преобразовывает в относительные.
Пример:
При /unfix команда в командном блоке вида /tp @p[x=1,y=2,z=3,r=4] 1 2 3 преобразуется в /tp @p[x=1,y=2,z=3,r=4] <x> <y> <z>, где то, что в <> скобках - относительные координаты (и наоборот, при /fix - в абсолютные)
При таких действиях будет сохранятся работоспособность конструкции. Но перемещать её всё-равно в большинстве случаев будет нельзя, потому что есть ещё квадратные скобки, в них координаты могут ссылаться на другие части внутри механизма, при перемещении эти координаты будут ссылаться всё на те же места МИРА. Для этого есть флаг /all (для обеих команд) - делает то же самое, но ещё и в квадратных скобках. Minecraft НЕ поддерживает относительные координаты в квадратных скобках, поэтому при использовании /unfix /all для работы механизма после перемещения надо ОБЯЗАТЕЛЬНО выполнить /fix /all на нём. Подробнее показано в видео.

//cs UltraCommandBlock /createtemplate
Ну и осталась последняя команда, которая пока в стадии разработки. Эта команда работает с любым типом выделения. Мы что-либо выделяем и нам создаётся набор командных блоков по маске (пока доступно 4 переменных - $x$, $y$, $z$ и $block_id$, которые соответствуют координатам рассматриваемого блока из выделения и его id), которую мы записали в командный блок, на который встали. Всё подробно показано в видео. Описывать подробно не буду, так как команда не доработана.
Примеры:
//cs UltraCommandBlock /createtemplate
//cs UltraCommandBlock /createtemplate +:12,34,56
//cs UltraCommandBlock /createtemplate -:12,34,56

Так же в данном скрипте раз в сутки выводится реклама, которая указывает на создателей скрипта и даёт их координаты для связи.
В планах: доработка /createtemplate, на 1.7 версии создание функционала работы с вагонетками с командными блоками (их спавн, заполнение и так далее).




